# 技術選択の背景

## 1. トランスポート層の選択

### 選択: stdio（標準入出力）

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **stdio** | ✅ 採用 | Claude Codeの`mcp serve`コマンドがstdioをサポート |
| **TCP** | ❌ 却下 | `mcp serve`がTCPをサポートしていない |
| **HTTP** | ❌ 却下 | `mcp serve`がHTTPサーバーとして機能しない |

### 採用の理由

1. **公式サポート**: Claude Codeが`mcp serve`コマンドでstdio MCPサーバーとして機能することを公式にサポート
2. **シンプルさ**: 追加のネットワーク設定が不要
3. **プロセス分離**: 各インスタンスが独立したプロセスとして動作
4. **セキュリティ**: ローカルホスト内でのみ通信可能

### 代替案との比較

#### TCPソケット方式（採用せず）

```
【メリット】
- リモート通信が可能
- 複数マシンでのスケーラビリティ

【デメリット】
- Claude Codeの`mcp serve`がTCPをサポートしていない
- 追加のプロキシプロセスが必要
- 設定が複雑になる
```

#### HTTPサーバー方式（採用せず）

```
【メリット】
- 既存のHTTPライブラリを活用可能
- デバッグが容易

【デメリット】
- Claude Codeの`mcp serve`がHTTPサーバーとして機能しない
- オーバーヘッドが大きい
```

## 2. 通信プロトコルの選択

### 選択: MCP（Model Context Protocol）

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **MCP** | ✅ 採用 | Claude Codeの公式プロトコル |
| **独自プロトコル** | ❌ 却下 | 再発明、互換性なし |

### 採用の理由

1. **公式プロトコル**: Anthropicが策定したオープン標準
2. **Claude Codeとの統合**: 最適な統合が可能
3. **JSON-RPC 2.0ベース**: 標準的なRPCプロトコル
4. **ツール・リソース・プロンプト**: 豊富な機能

### MCPの構成要素

| 要素 | 説明 | orchestrator-ccでの用途 |
|------|------|------------------------|
| **Tools** | 実行可能な機能 | メッセージ送信・タスク実行 |
| **Resources** | 静的なデータ | 共有コンテキスト・設定 |
| **Prompts** | プロンプトテンプレート | タスクテンプレート |

## 3. プロセス管理の選択

### 選択: asyncio.subprocess

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **asyncio.subprocess** | ✅ 採用 | Python標準、非同期I/O対応 |
| **multiprocessing** | ❌ 却下 | プロセス間通信が複雑 |
| **subprocess** | ❌ 却下 | 同期API、非同期処理に不向き |

### 採用の理由

1. **Python標準**: 追加の依存関係なし
2. **非同期I/O**: 複数プロセスとの同時通信が可能
3. **既存コードの再利用**: orchestratorプロジェクトのProcessLauncherで使用

### 既存コードの再利用

| コンポーネント | 元ファイル | 再利用内容 |
|--------------|-----------|-----------|
| **ProcessLauncher** | `orchestrator/core/process_launcher.py` | プロセス起動・管理・グレースフルシャットダウン |
| **ClusterManager** | `orchestrator/core/cluster_manager.py` | 複数プロセスの一元管理 |
| **MCPClient** | `orchestrator/llm/providers/mcp_client.py` | MCP通信クライアント |

## 4. データモデルの選択

### 選択: Pydantic

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **Pydantic** | ✅ 採用 | 型安全、バリデーション、JSONシリアライズ |
| **dataclass** | ❌ 却下 | バリデーション機能が弱い |
| **TypedDict** | ❌ 却下 | 不変性、ランタイムチェックなし |

### 採用の理由

1. **型安全**: 実行時の型チェック
2. **バリデーション**: 自動的なデータ検証
3. **JSONシリアライズ**: MCPメッセージへの変換が容易
4. **既存コードとの統合**: orchestratorプロジェクトで使用

## 5. CLIフレームワークの選択

### 選択: Typer

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **Typer** | ✅ 採用 | orchestratorプロジェクトで使用 |
| **Click** | ❌ 却下 | 既存コードとの統合が不要 |
| **argparse** | ❌ 却下 | コードが冗長になる |

### 採用の理由

1. **既存コードとの統合**: orchestratorプロジェクトのCLIで使用
2. **シンプルさ**: 最小限のコードでCLIを構築
3. **型ヒント対応**: 型安全な引数定義

## 6. 性格づけの方法

### 選択: システムプロンプト（--system-prompt）

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **--system-prompt** | ✅ 採用 | Claude Codeが公式サポート |
| **最初のメッセージ** | ❌ 却下 | 信頼性が低い |
| **会話履歴への注入** | ❌ 却下 | 文脈依存、不安定 |

### 採用の理由

1. **公式サポート**: Claude Codeが`--system-prompt`オプションを提供
2. **最も信頼性が高い**: システムプロンプトは最優先される
3. **簡単な実装**: コマンドライン引数で指定可能

### 実装方法

```bash
claude mcp serve --system-prompt "$(cat config/personalities/grand_boss.txt)"
```

## 7. 思考ログの実装方法

### 選択: メッセージ内に思考ログフィールドを含める

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **メッセージ内フィールド** | ✅ 採用 | シンプル、メッセージと一緒に送信 |
| **別チャネル** | ❌ 却下 | 実装が複雑 |
| **ログファイル** | ❌ 却下 | リアルタイム性が低い |

### 採用の理由

1. **シンプルさ**: 追加の通信チャネルが不要
2. **同期性**: メッセージと思考ログが同期される
3.拡張性**: メタデータを追加可能

### メッセージ構造

```json
{
  "from": "grand_boss",
  "to": "middle_manager",
  "type": "task_request",
  "content": "タスクの分解をお願い",
  "thinking": "これは複雑なタスクだな。Middle Managerに分解してもらおう。",
  "metadata": {
    "timestamp": "2026-02-01T14:32:10Z",
    "priority": "normal",
    "thinking_log_detail": "detailed"
  }
}
```

## 8. Webダッシュボード（Phase 4）

### 選択: FastAPI + WebSocket

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **FastAPI + WebSocket** | ✅ 採用 | 非同期対応、リアルタイム通信 |
| **Flask + Server-Sent Events** | ❌ 却下 | 同期API、拡張性が低い |
| **Django + Channels** | ❌ 却下 | 重量、オーバーヘッドが大きい |

### 採用の理由

1. **非同期対応**: asyncioとの統合が容易
2. **リアルタイム通信**: WebSocketで双方向通信が可能
3. **軽量**: 必要最小限の機能
4. **型ヒント対応**: Pydanticとの統合が容易

## 9. テストフレームワーク

### 選択: pytest + pytest-asyncio

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **pytest + pytest-asyncio** | ✅ 採用 | orchestratorプロジェクトで使用 |
| **unittest** | ❌ 却下 | 非同期テストのサポートが弱い |
| **nose2** | ❌ 却下 | メンテナンスが低活性 |

### 採用の理由

1. **既存コードとの統合**: orchestratorプロジェクトで使用
2. **非同期テスト対応**: pytest-asyncioで非同期コードをテスト可能
3. **豊富なプラグイン**: 拡張性が高い

## 10. ログ管理

### 選択: 標準出力 + ファイル出力

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **標準出力 + ファイル出力** | ✅ 採用 | シンプル、デバッグ容易 |
| **ロギングライブラリ（structlog）** | ❌ 却下 | 過剰な機能 |
| **集中ログ管理（ELK）** | ❌ 却下 | 運用コストが高い |

### 採用の理由

1. **シンプルさ": 追加の依存関係なし
2. **デバッグ容易**: 標準出力でリアルタイムに確認可能
3. **永続化**: ファイル出力でログを保存

## 11. コード品質管理

### 選択: mypy + ruff + pytest

| ツール | 役割 | 採用理由 |
|--------|------|----------|
| **mypy** | 静的型チェック | 型安全の保証 |
| **ruff** | リント・フォーマット | 高速、Rust製 |
| **pytest** | テスト実行 | 非同期テスト対応 |

### 採用の理由

1. **既存コードとの統合**: orchestratorプロジェクトと同じツールセット
2. **高速**: ruffはRust製で高速
3. **統合**: 一括品質チェックスクリプトで実行可能

## 12. 設定管理

### 選択: YAMLファイル

| 選択肢 | 評価 | 採用理由 |
|--------|------|----------|
| **YAML** | ✅ 採用 | 人間が読み書きしやすい |
| **JSON** | ❌ 却下 | コメント不可、扱いにくい |
| **TOML** | ❌ 却下 | Python以外のツールで扱いにくい |

### 採用の理由

1. **可読性**: 人間が読み書きしやすい
2. **コメント対応**: 設定の意図をコメントで残せる
3. **既存コードとの統合**: orchestratorプロジェクトで使用

## 技術選択の総括

| カテゴリ | 選択技術 | 理由 |
|---------|----------|------|
| **トランスポート** | stdio | Claude Code公式サポート |
| **プロトコル** | MCP | 標準プロトコル |
| **プロセス管理** | asyncio.subprocess | Python標準、非同期対応 |
| **データモデル** | Pydantic | 型安全、バリデーション |
| **CLI** | Typer | 既存コードとの統合 |
| **性格づけ** | --system-prompt | 公式サポート |
| **思考ログ** | メッセージ内フィールド | シンプル |
| **Web** | FastAPI + WebSocket | 非同期対応 |
| **テスト** | pytest + pytest-asyncio | 既存コードとの統合 |
| **品質管理** | mypy + ruff | 既存コードとの統合 |
| **設定** | YAML | 可読性 |

すべての技術選択において、「**既存コードの再利用**」と「**公式機能の使用**」を重視しています。
